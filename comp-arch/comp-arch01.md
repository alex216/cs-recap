# 01 Digital circuit

## 抽象化

コンピュータでは一般的には連続的な値ではなく,**離散的な値**を扱います

その理由は離散値とすることで物事を抽象化し,複雑なシステムを扱いやすくできるからです

電子計算システムでは以下のような抽象化の構造が取られています

|アプリケーション･ソフトウェア|プログラム|
|-|-|
|OS|デバイス･ドライバ|
|アーキテクチャ|命令･レジスタ|
|マイクロアーキテクチャ|データパス･コントローラ|
|論理|加算器･メモリ|
|デジタル回路|ANDゲート･NOTゲート|
|アナログ回路|増幅器･フィルタ|
|デバイス(素子)|トランジスタ･ダイオード|
|物理|電子|

ここではこの表のうち,デジタル回路を扱います

## 離散

離散的とは切れ目がある値ということです

デジタル回路では**ブール代数**という離散的な値を扱う数学を利用します

ブール代数ではTRUEとFALSEの2値を扱いますが,デジタル回路では高い電圧を1=TRUE,低い電圧を0=FALSEとして扱うものが多いです.ここではそれに従います

## n進数

n進数は右端の桁から重みが$n^0, n^1, n^2,\ldots$となっています.これをnを基数とする表現といいます.それぞれの桁は0からn-1までの整数を表しています

また,n進数の値だということを明記したい場合は$1234_{(n)}$と右下に基数を書きます

$$
1234_{(10)} = 1 \cdot 10^3 + 2 \cdot 10^2 + 3 \cdot 10^1 + 4 \cdot 10^0
$$

### 変換

デジタルな値は2進数なので2進数に関する変換について書きます

10進数から2進数に変換するには下のようにやります

$$
\begin{aligned}
10_{(10)} &= 1 \cdot 2^3 + 0 cdot 2^2 + 1 \cdot 2^1 + 0 \cdot 2^0\\
&=1010_{(2)}
\end{aligned}
$$

逆は次のようになります

$$
\begin{aligned}
    10_{(2)} &= 1 \cdot 2^1 + 1 \cdot 2^0\\
    &= 2 + 0 = 2
\end{aligned}
$$

次に16進数から2進数に変換する方法について話します.

- 16は2の累乗である
- 0~9とA,B,C,D,Eという人間でも扱いやすい数で書ける
- 2進数の値を短く圧縮できる

という理由からよく使われます

16進数の1桁は2進数の4桁分,2進数の4桁は16進数の1桁分であるということを使って変換をします

16進数→2進数

$$
\begin{aligned}
2ED_{(16)} &= \underbrace{2}_{0010_{(2)}} \cdot 16^2 + \underbrace{E}_{1111_{(2)}} \cdot 16^1 + \underbrace{D}_{1110_{(2)}} \cdot 16^0\\
&= 0010,1111,1110_{(2)} = 10,1111,1110_{(2)}
\end{aligned}
$$

2進数→16進数

$$
\begin{aligned}
    1101,0110 = C6_{(2)}
\end{aligned}
$$

## 単位

1か0を表せるような値の単位を**ビット**と言います

8ビットで1**バイト**,4ビットで1**ニブル**です

マイクロプロセッサはデータを**ワード**というかたまりで処理し,nビットのワードを処理するプロセッサをnビットプロセッサと言います

複数ビットの中で最も小さい値を表現するビットを**最上位値ビット**(most significant bit, msb),最も小さい値を表現するビットを**最下位値**ビット(least significant bit, lsb)と呼びます

$2^10 \approx 10^3$をキロ,$2^20 \approx 10^6$をメガ,$2^30 \approx 10^9$をギガと言います

繰り上がりのことを**キャリ**と言い,繰り上げされるビットのことを**キャリビット**と言います

加算の結果,使えない桁にキャリビットが入ることを**オーバーフロー**(桁溢れ)と言います

## 符号

今までは符号(プラスマイナス)を考えていませんでした.符号を考える時,msbを符号化ビットとして使います.msbが1なら負,0なら正とします.

N桁の値だとして,残りのN-1桁で値を表現します

しかしこのままだと負の値と正の加算した際に値が正確に計算されません.そのために**2の補数**を導入します

これは｢符号ビット以外のビットを反転させて1を足すことでプラスマイナスを反転させた数｣のことです

$11_{(10)} = 01011_{(2)}$の2の補数は$-11=10100_{(2)} + 1_{(1)} = 10101_{(2)}$となります

これによりNビットで$[-2^{N-1}, 2^{N-1}-1]$の整数を表現できます.N+1桁目へのキャリは無視するのでオーバーフローではありませんが,同じ正負の和により符号が変わるのはオーバーフローです

\\[ \mu = \frac{1}{N} \sum_{i=0} x_i \\]
