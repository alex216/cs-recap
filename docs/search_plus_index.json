{"./":{"url":"./","title":"Computer Science Recapitulaion","keywords":"","body":"CS Recap ここではComputer Scienceに関連する分野で自分が勉強した内容を書いていきます 間違った内容などがあったら是非青い鳥にDM or リプライをするかプルリクエストをして下さい 文中ではOSをUbuntu(18.04以降)かMac OSを(Mojave以降)を想定しています 内容に関する注意 本文に従って何かしらの不利益を被った際の責任は取りませんのであしからず Core CSの基礎となるような内容です Math Calculus Linear algebra Statistics Set & Phase Physics Electromagnetics CS Discrete Math Algorithm Computer Architecture C Language Selective Coreの内容を土台とする発展的な内容です Information theory Operating system Other topics 関連した内容です Editor Latex Git "},"cal/cal.html":{"url":"cal/cal.html","title":"Calculus","keywords":"","body":"Calculus "},"linear-alge/linear-alge.html":{"url":"linear-alge/linear-alge.html","title":"Linear algebra","keywords":"","body":"Linear algebra "},"stat/stat.html":{"url":"stat/stat.html","title":"Statistics","keywords":"","body":"Statistics "},"set-phase/set-phase.html":{"url":"set-phase/set-phase.html","title":"Set & Phase","keywords":"","body":"Set & Phase "},"elec/elec.html":{"url":"elec/elec.html","title":"Electromagnetics","keywords":"","body":"Electromagnetics "},"elec/math.html":{"url":"elec/math.html","title":"Basic Math","keywords":"","body":"Basic Math "},"elec/cou-gau.html":{"url":"elec/cou-gau.html","title":"Coulomb & Gaussian","keywords":"","body":"Coulomb & Gaussian "},"elec/potential.html":{"url":"elec/potential.html","title":"Potential","keywords":"","body":"Potential "},"dis-math/dis-math.html":{"url":"dis-math/dis-math.html","title":"Discrete Math","keywords":"","body":"Discrete Math 情報科学で使われる様々な概念を把握するのに必要となる知識 Set "},"dis-math/set.html":{"url":"dis-math/set.html","title":"Set","keywords":"","body":"Set theory 集合 集合とは｢順序付けられていない,どんなものでもいい(集合も含めて)異なるものの集まり｣です この｢もの｣を要素と言います 要素にはあらゆるものが成れます 数字だけでなく,人間や植物,惑星も｢もの｣です 集合は外延的記法(set notation)という\"{}\"という要素をくくった書き方で表現できます 外延的記法の例 中括弧(brace),つまり{\\lbrace{と}\\rbrace}で囲みます コンマ(,,,)で区切ります 例:{日本人,田中くん,魚}\\lbrace\\text{日本人}, \\text{田中くん}, \\text{魚}\\rbrace{日本人,田中くん,魚} 集合では同じ要素のことは考慮しません 下の集合は全て,｢焼肉定食｣,｢コンパイラ｣,｢114514｣を含む集合を表しており同じ集合です {焼肉定食,コンパイラ,114514}{コンパイラ,焼肉定食,コンパイラ,114514,114514}{コンパイラ,コンパイラ,コンパイラ,焼肉定食,コンパイラ,114514} \\begin{aligned} &\\lbrace \\text{焼肉定食}, \\text{コンパイラ}, 114514\\rbrace\\\\ &\\lbrace \\text{コンパイラ}, \\text{焼肉定食}, \\text{コンパイラ}, 114514, 114514\\rbrace\\\\ &\\lbrace \\text{コンパイラ}, \\text{コンパイラ}, \\text{コンパイラ}, \\text{焼肉定食}, \\text{コンパイラ}, 114514\\rbrace \\end{aligned} ​{焼肉定食,コンパイラ,114514}{コンパイラ,焼肉定食,コンパイラ,114514,114514}{コンパイラ,コンパイラ,コンパイラ,焼肉定食,コンパイラ,114514}​ 繰り返し出てくる要素は無視されます {1,2,2,2,2}\\lbrace1, 2, 2, 2, 2\\rbrace{1,2,2,2,2}という集合は,{1,2}\\lbrace1, 2\\rbrace{1,2}という集合と同じ集合なのです 集合と要素 空集合とは要素を持たない集合です つまり,{}\\lbrace\\rbrace{}のような集合です.0にスラッシュを付けたような記号で表します {}=∅ \\lbrace\\rbrace = \\emptyset {}=∅ また,集合と要素は区別します 1≠{1} 1 \\ne \\lbrace1\\rbrace 1≠{1} また,集合は集合も要素として持てます 下のように空集合と,空集合を持った集合は等しいのでしょうか? ∅=?{∅} \\emptyset \\overset{?}{=} \\lbrace\\emptyset\\rbrace ∅=?{∅} もちろん違います.∅\\emptyset∅は要素を持たない集合なので,空集合を要素に持つ集合とは等しくありません. よって正しい式は次の通りです ∅≠{∅} \\emptyset \\ne \\lbrace\\emptyset\\rbrace ∅≠{∅} あるもの(aaaとします)がある集合(AAAとします)に入っていることをaaaはAAAに｢属する｣と言います これを式にすると以下の通り a∈A a \\in A a∈A {1,2,3,4,5,6}\\lbrace1,2,3,4,5,6\\rbrace{1,2,3,4,5,6}という集合について考えます この集合に111は属しているでしょうか? もちろん,111は属しています.つまり以下のように書けます 1∈{1,2,3,4,5,6} 1 \\in \\lbrace1,2,3,4,5,6\\rbrace 1∈{1,2,3,4,5,6} では,777はこの集合に属しているのでしょうか? この集合に777はないので属していません よって,次のように書けます 7≠∈{1,2,3,4,5,6} 7 \\ne \\in \\lbrace1,2,3,4,5,6\\rbrace 7≠∈{1,2,3,4,5,6} 有限集合と無限集合 今までは要素が有限な集合について扱っていました ここでは要素の無限に多い集合を扱しています 例えばN={0,1,2,3,..}\\mathbb{N}=\\lbrace0,1,2,3,..\\rbraceN={0,1,2,3,..}は全ての自然数の集合です CSでは自然数に0を含むことが多いのでここでは0を自然数に含めています 英語で自然数はNatural number Z={...,−2,−1,0,1,2,...}\\mathbb{Z}=\\lbrace..., -2, -1,0,1,2,...\\rbraceZ={...,−2,−1,0,1,2,...}は全ての整数の集合です ドイツ語で整数はZahlen(英語ではInteger) 外延的記法では｢全ての自然数の集合｣のような集合を厳密に書けません このような集合を数学的に書くには内包的記法 (set-builder notation)を用います 以下のように内包的記法は書きます {\\lbrace{と∣\\mid∣と}\\rbrace}で区切ります ∣\\mid∣の左側に集合の要素を書きます ∣\\mid∣の右側にその集合の満たす条件を書きます 例:{∣n∈N and n is odd}\\lbrace \\mid n \\in \\mathbb{N} \\text{ and n is odd}\\rbrace{∣n∈N and n is odd} ちなみに∣\\mid∣はLATXE\\LaTeXLATE​Xで書く際は\\midを使います つまり {∣xが満たすある条件} \\lbrace \\mid \\text{xが満たすある条件}\\rbrace {∣xが満たすある条件} という風に書くのが内包的記法です 集合の組み合わせ 集合を組み合わせて,共通する要素などを表現することができます ベン図 ベン図は集合の組み合わせを視覚的に表現したものです 図はこちらで見るといいでしょう 具体的に以下のようなものがあります また,A={1,2,3}A=\\lbrace1,2,3\\rbraceA={1,2,3}, B={3,4,5}B=\\lbrace3,4,5\\rbraceB={3,4,5}とします 和集合(Union)は少なくともどちらかの集合に含まれる要素の集合 A∨B={1,2,3,4,5}A \\lor B = \\lbrace 1,2,3,4,5\\rbraceA∨B={1,2,3,4,5} 共通部分(intersection )はどちらの集合にも含まれる要素の集合 A∧B={3}A \\land B =\\lbrace 3\\rbraceA∧B={3} 差集合(difference)は片方の集合に含まれる要素を抜いた要素の集合 A−B={1,2}A - B=\\lbrace1,2\\rbraceA−B={1,2} もしくは A∖B={1,2}A \\setminus B = \\lbrace1,2\\rbraceA∖B={1,2} 排他的論理和(Symmetric Difference)はどちらの集合にも含まれる要素の集合を和集合から引いたもの AΔB={1,2,4,5}A \\Delta B = \\lbrace1,2,4,5\\rbraceAΔB={1,2,4,5} 部分集合と冪集合 部分集合 もし,集合Aの全ての要素が集合Bの要素でもあるとき,集合Aは集合Tの部分集合 (subset)だと言います A⊆B A \\subseteq B A⊆B ここで注意したいことがあります.S∈TS\\in TS∈TとS⊆TS \\subseteq TS⊆Tの違いです S∈TS \\in TS∈TはSという要素がTに含まれるということを意味しています S⊆TS \\subseteq TS⊆TはSに含まれる全ての要素がTに含まれるということを意味しています このように明確な違いが有ります また,ここで浮かぶ疑問は｢∅はどう扱われるのだろう?｣ということだと思います 実は∅は全ての集合の部分集合なのです PとQがあるとします.Pが何も持っていないとき｢Pが持つ全てのものはQのものでもある｣という命題は真と定義されています これを\"Vacuously true\"であると言います 例えば,彼女がいない人が｢俺の彼女はとてもかわいい｣と言った場合は真です 俺の彼女∈かわいい \\text{俺の彼女} \\in \\text{かわいい} 俺の彼女∈かわいい 同様に∅\\emptyset∅も要素を持たないので,｢全ての集合は∅の要素を含む｣という命題もまた真です 冪集合 冪集合(power set)とはある集合の全ての集合を含む集合のことです.ちなみにべきしゅうごうと呼びます 定義は下の通り ℘(S)={T∣T∈S} \\wp(S) = \\lbrace T \\mid T\\in S\\rbrace ℘(S)={T∣T∈S} 例えば,A={1,2}A = \\lbrace 1,2\\rbraceA={1,2}の冪集合は℘(A)={∅,{1},{2},{1,2}}\\wp(A) = \\lbrace \\emptyset, \\lbrace 1\\rbrace, \\lbrace 2\\rbrace, \\lbrace 1, 2\\rbrace\\rbrace℘(A)={∅,{1},{2},{1,2}}です では∅の冪集合は何でしょうか? ∅ですね 濃度 濃度(cardinality)とは集合の含む要素の数のことです 集合SSSの濃度は∣S∣|S|∣S∣と書きます S={1,2}S = \\lbrace 1, 2\\rbraceS={1,2}のとき,∣S∣=2|S| = 2∣S∣=2ですね 無限集合 ここで問題です 自然数の集合N\\mathbb{N}Nの濃度は一体なんでしょうか 自然数の集合は無限に多くの数を持っています.そのため,自然数ではありません ここで,ℵ0=∣N∣\\aleph_0 = |\\mathbb{N}|ℵ0​=∣N∣とします.読み方は\"aleph-zero\" or \"aleph-nought\" or \"aleph-null\"です 集合の濃度が同じということはどのように定義されているのでしょうか. ｢2つの集合の要素を余らすことなく1組に対応付けられる場合,2つの集合の濃度が等しい｣と定義されています 集合S={n∣n∈N and n is even}S = \\lbrace n \\mid n\\in \\mathbb{N} \\text{ and n is even}\\rbraceS={n∣n∈N and n is even}という集合はn↔2nn \\leftrightarrow 2nn↔2nと対応付ければ自然数の集合N\\mathbb{N}Nと1組に対応付けられます そのため,これらの集合の濃度は同じです また,有理数の集合Z\\mathbb{Z}Zも自然数と濃度は同じです Z\\mathbb{Z}Zの要素が非負数のときN\\mathbb{N}Nの偶数の要素と組付け,Z\\mathbb{Z}Zの要素が負数のとき,N\\mathbb{N}Nの奇数の要素と組み付ければ良いのです カントールの定理 カントールの定理 (Cantor's theorem )とは全ての集合はその冪集合より小さいとする定理です これより,すべて無限集合は同じ大きさではありません つまり,無限に無限に多くの無限集合があるということになります これがどうコンピュータと関係するのか 文字列は文字 (アルファベット･数字･漢字など )からなるものだとします このとき 多くても文字列と同じだけのプログラムがある 少なくとも文字列の集合と同じだけの問題がある ということが言えます コンピュータのソースコードは文字列です.昔はパンチカード,今は高性能のIDEで書かれているかもしれませんが基本は変わっていません そのため,すべてのプログラムは文字列からできており, (1 )が成り立ちます すべての問題は文字列の集合からなります 例えば000~999からなる文字列が奇数か偶数か判定するというもの このように問題は文字列の集合からなります.そのため (2 )が成り立ちます つまりカントールの定理から以下のようなことが言えるわけです ∣programs∣≤∣string∣≤∣℘(strings)∣≤∣problems∣ |\\text{programs}| \\leq |\\text{string}| \\leq |\\wp(\\text{strings})| \\leq |\\text{problems}| ∣programs∣≤∣string∣≤∣℘(strings)∣≤∣problems∣ そして,コンピュータで解ける問題というのはほとんどないということがわかります そのため,離散数学を使ってこれについて考える必要があるというわけです まとめ 集合は順序の関係の異なる要素が集まったもの 外延的記法と内包的記法がある 空集合は要素を持たない AAAの要素が全てBBBに含まれる時,AAAはBBBの部分集合であると言う ある集合の要素からなる全ての集合からなる集合を冪集合と言う 集合の持つ要素の数を濃度と言う カントールの定理から全ての集合はその冪集合よりも小さい "},"dis-math/proof.html":{"url":"dis-math/proof.html","title":"Proof","keywords":"","body":"Proof "},"algo/algo.html":{"url":"algo/algo.html","title":"Algorithm","keywords":"","body":"Algorithm OS,暗号技術,人工知能,ネットワーク,コンパイラー...などなどあらゆる情報科学の分野で必要となる知識 Order "},"algo/order.html":{"url":"algo/order.html","title":"Order","keywords":"","body":"Order アルゴリズムを考える際,一つの指標となるのが計算量です 計算量とは空間計算量･時間計算量がありますがどちらも基本となる考え方は同じです ここでは時間計算量について考えます Asymptotic Analysis 計算量とはそのアルゴリズムがどのような関数に漸近するのかを考えたものです そのため,以下のようなメリット･デメリットがあります メリット 環境に依存しないアルゴリズムそのものの良し悪しについて考えられる よりアルゴリズムを取り扱いやすくする デメリット 入力が大きい時しか考慮していない この計算量を求める方法は Tree Method Master Theorem(Generalized Method) Substitution Method 以上の3種類が有ります Tree Methodを一般化したものなので以下ではMaster TheoremとSustitution Method を扱います その前に計算量の記法について学びましょう 計算量記法 ここではBig-O記法･Big-Omega記法･Big-Theta記法について考えます Big-O T(n)T(n)T(n)(計算にかかる時間で,値は正で単調増加だとします)とg(n)g(n)g(n)が正の整数の関数だとします ∃c,n0>0 s.t. ∀n≥n00≤T(n)≤cg(n) \\begin{aligned} &\\exists{c, n_0} > 0 \\text{ s.t. } \\forall{n} \\geq n_0 \\\\ &0 \\leq T(n) \\leq cg(n) \\end{aligned} ​∃c,n0​>0 s.t. ∀n≥n0​0≤T(n)≤cg(n)​ であるとき,T(n)∈O(g(n))T(n) \\in O(g(n))T(n)∈O(g(n))とします ` ある000より大きいn0n_0n0​以上のnnnでは,常にT(n)T(n)T(n)はg(n)g(n)g(n)の定数倍よりも小さいということです つまり,無限に大きいnnnでg(n)g(n)g(n)はT(n)T(n)T(n)の上限であるということです T(n)∈O(g(n))T(n) \\in O(g(n))T(n)∈O(g(n))はT(n)=O(g(n))T(n) = O(g(n))T(n)=O(g(n))とも書きます(こう書く場合の方が多いです) Big-Omega Big-O記法は上限を表現するためでしたが,Big-Omega記法は下限を表現するための記法です 上と同じ関数T(n)T(n)T(n)とg(n)g(n)g(n)を用いて ∃c,n0>0 s.t. ∀n≥n00≤cg(n)≤T(n) \\begin{aligned} &\\exists{c, n_0} > 0 \\text{ s.t. } \\forall{n} \\geq n_0 \\\\ &0 \\leq cg(n) \\leq T(n) \\end{aligned} ​∃c,n0​>0 s.t. ∀n≥n0​0≤cg(n)≤T(n)​ のときT(n)∈Ω(g(n))T(n) \\in \\Omega(g(n))T(n)∈Ω(g(n))もしくはT(n)=Ω(g(n))T(n) = \\Omega(g(n))T(n)=Ω(g(n))とします ある000より大きいn0n_0n0​以上のnnnでは,常にT(n)T(n)T(n)はg(n)g(n)g(n)の定数倍よりも大きいということです つまり,無限に大きいnnnでg(n)g(n)g(n)はT(n)T(n)T(n)の下限であるということです Big-Theta Big-Theta記法は上の記法のどちらもが当てはまるときです つまり,以下の式を満たします ∃c0,c1,n0>0 s.t. ∀n≤n00≤c0⋅g(n)≤f(n)≤c1⋅g(n) \\begin{aligned} \\exists{c_0, c_1, n_0} &> 0 \\text{ s.t. } \\forall{n} \\leq n_0 \\\\ 0 &\\leq c_0 \\cdot g(n) \\leq f(n) \\leq c_1\\cdot g(n) \\end{aligned} ∃c0​,c1​,n0​0​>0 s.t. ∀n≤n0​≤c0​⋅g(n)≤f(n)≤c1​⋅g(n)​ Big-Theta記法は無限に大きいnnnでg(n)g(n)g(n)の定数倍にT(n)T(n)T(n)が挟まれる状態にあるということです Master Theorem 最初に定理を紹介し,あとから説明をします a≥1a\\geq 1a≥1, b≥1b \\geq 1b≥1, dddをnnnに独立な定数とします このときT(n)=a⋅T(nb)+O(nd)T(n)=a \\cdot T(\\frac{n}{b}) + O(n^d)T(n)=a⋅T(bn​)+O(nd)とすると以下の式を満たします T(n)={O(ndlog(n))(a=bd)O(nd)(abd)O(nlogb(a))(a>bd) T(n) = \\begin{cases} O(n^{d}log(n)) (a = b^d) \\\\ O(n^d) (a b^d) \\end{cases} T(n)=⎩⎪⎨⎪⎧​O(ndlog(n))(a=bd)O(nd)(abd)O(nlogb​(a))(a>bd)​ この定理を分類定理(master theorem)と言います aaa : 分割された下位問題の数 bbb : 入力の大きさが縮む倍率(2→12 \\rightarrow 12→1のときはb=2b=2b=2) ddd : 全ての問題を分割し統合するのに必要な計算量 この定理は問題を分割し,それらを更に分割し解くという考えを使っています(これを再帰と言います) 入力がnnnの問題をT(n)T(n)T(n)で解くアルゴリズムを考えます 入力nnnをaaa個に分割する 分割された入力をT(nb)T(\\frac{n}{b})T(bn​)で解く 分割された各アルゴリズムに対してかかる時間が(O(nlog⁡b(a))(O(n^{\\log_{b}(a)})(O(nlogb​(a))である このようにするとT(n)T(n)T(n)は上のような式になります.実際にそれぞれのケースごとに正しいか確認してみましょう a=bda=b^da=bdの場合 T(n)=c⋅nd⋅∑t=0log⁡b(n)(abd)t=c⋅nd⋅∑t=0log⁡b(n)1=c⋅nd⋅(log⁡b(n)+1)=c⋅nd⋅(log⁡(n)log⁡(b)+1)=O(ndlog⁡(n)) \\begin{aligned} T(n) &= c\\cdot n^d \\cdot \\sum_{t=0}^{\\log_b(n)}(\\frac{a}{b^d})^t \\\\ &= c \\cdot n^d \\cdot \\sum_{t=0}^{\\log_b(n)}1 \\\\ &= c \\cdot n^d \\cdot (\\log_b(n) + 1) \\\\ &= c \\cdot n^d \\cdot (\\frac{\\log(n)}{\\log(b)} + 1) \\\\ &= O(n^d \\log(n)) \\end{aligned} T(n)​=c⋅nd⋅t=0∑logb​(n)​(bda​)t=c⋅nd⋅t=0∑logb​(n)​1=c⋅nd⋅(logb​(n)+1)=c⋅nd⋅(log(b)log(n)​+1)=O(ndlog(n))​ abda abdの場合 T(n)=c⋅nd⋅∑t=0log⁡b(n)(abd)t⏞1未満 T(n) = c\\cdot n^d \\cdot \\sum_{t=0}^{\\log_b(n)}\\overbrace{(\\frac{a}{b^d})^t}^{1\\text{未満}} T(n)=c⋅nd⋅t=0∑logb​(n)​(bda​)t​1未満​ ここで,等比級数の和は一般項xxxが1より大きい時は次数が最大の項が支配的になり,xxxが0より大きく1より小さい時は次数が最小の項が支配的になる ここでは∑t=0log⁡b(n)(abd)t\\sum_{t=0}^{\\log_b(n)}(\\frac{a}{b^d})^t∑t=0logb​(n)​(bda​)tの一般項は後者なので定数として扱える T(n)=c⋅nd⋅∑t=0log⁡b(n)(abd)t⏞1未満=c⋅nd⋅定数=O(nd) \\begin{aligned} T(n) &= c\\cdot n^d \\cdot \\sum_{t=0}^{\\log_b(n)}\\overbrace{(\\frac{a}{b^d})^t}^{1\\text{未満}} \\\\ &= c \\cdot n^d \\cdot \\text{定数} \\\\ &= O(n^d) \\end{aligned} T(n)​=c⋅nd⋅t=0∑logb​(n)​(bda​)t​1未満​=c⋅nd⋅定数=O(nd)​ a>bda > b^da>bdの場合 上の例で扱ったように一般項に注目する T(n)=c⋅nd⋅∑t=0log⁡b(n)(abd)t⏞1より大きい=O(nd(abdlogb(n)))=O(nlog⁡b(a)) \\begin{aligned} T(n) &= c\\cdot n^d \\cdot \\sum_{t=0}^{\\log_b(n)}\\overbrace{(\\frac{a}{b^d})^t}^{1\\text{より大きい}} \\\\ &=O(n^d(\\frac{a}{b^d}^{log_b(n)})) \\\\ &=O(n^{\\log_b(a)}) \\end{aligned} T(n)​=c⋅nd⋅t=0∑logb​(n)​(bda​)t​1より大きい​=O(nd(bda​logb​(n)))=O(nlogb​(a))​ Substitution Method これは以下の手順から成り立ちます 答えを推論する その推論が正しいと証明する 答えを得る 例 T(n)=2⋅T(n2)+nT(n) = 2 \\cdot T(\\frac{n}{2}) + nT(n)=2⋅T(2n​)+nという例をここでは扱います(ただしT(1)=1T(1)=1T(1)=1). 推論 この時,実際に手を動かしてみると T(n)=2⋅T(n2)+n=2⋅(2⋅T(n4)+n2)+n=4⋅T(n4)+2n=4⋅T(2⋅T(n8)+n4)+2n=8⋅T(n8)+3n=⋯ \\begin{aligned} T(n) &= 2 \\cdot T(\\frac{n}{2}) + n \\\\ &=2 \\cdot (2 \\cdot T(\\frac{n}{4}) + \\frac{n}{2}) + n \\\\ &= 4 \\cdot T(\\frac{n}{4}) + 2n \\\\ &= 4 \\cdot T(2 \\cdot T(\\frac{n}{8}) + \\frac{n}{4}) + 2n \\\\ &= 8 \\cdot T(\\frac{n}{8}) + 3n &= \\cdots \\end{aligned} T(n)​=2⋅T(2n​)+n=2⋅(2⋅T(4n​)+2n​)+n=4⋅T(4n​)+2n=4⋅T(2⋅T(8n​)+4n​)+2n=8⋅T(8n​)+3n​=⋯​ このようになり, T(n)=2t⋅T(n2t)+t⋅nT(n) = 2^t \\cdot T(\\frac{n}{2^t})+ t\\cdot nT(n)=2t⋅T(2tn​)+t⋅nになるのではないかと推測できます t=log(n)t=log(n)t=log(n)を代入し, T(n)=n⋅T(1)+log⁡(n)⋅(n)⋅n=n(log⁡(n)+1) T(n)= n \\cdot T(1) + \\log(n) \\cdot(n) \\cdot n = n(\\log(n) + 1) T(n)=n⋅T(1)+log(n)⋅(n)⋅n=n(log(n)+1) と推論できます 証明 数学的帰納法で証明します Inductive Hypothesis T(j)=j(log⁡(j)+1)T(j) = j(\\log(j)+1)T(j)=j(log(j)+1)が1≤j≤n1 \\leq j \\leq n1≤j≤nで成り立つと仮定します Base Case(n=1n=1n=1) T(1)=1=1⋅(log⁡(1)+1)T(1) = 1 = 1 \\cdot (\\log(1) + 1)T(1)=1=1⋅(log(1)+1)となり成り立ちます Inductive Step inductive hypothesisがn=k−1n=k-1n=k−1で成り立つと仮定します このとき定義からT(k)=2⋅T(k2)+kT(k)= 2 \\cdot T(\\frac{k}{2}) + kT(k)=2⋅T(2k​)+kであり,仮定よりT(k)=2⋅(k2(log⁡(k2)+1))+kT(k)= 2 \\cdot (\\frac{k}{2}(\\log(\\frac{k}{2})+1))+kT(k)=2⋅(2k​(log(2k​)+1))+kです.簡単にすると, T(k)=k(log⁡(k)+2) T(k)=k (\\log(k) + 2) T(k)=k(log(k)+2) となり,n=kn=kn=kでも成り立つことが示されました 結論 n≥1n \\geq 1n≥1 で T(n)=n(log⁡(n)+1)T(n) = n(\\log(n) + 1)T(n)=n(log(n)+1)とわかります このように事前の推論を数学的帰納法で証明することをSubstituion Methodと言います まとめ 計算量という概念を導入することでアルゴリズムの良し悪しが分かる 計算量を導く方法がある "},"comp-arch/comp-arch.html":{"url":"comp-arch/comp-arch.html","title":"Computer Architecture","keywords":"","body":"Computer Architecture "},"clang/clang.html":{"url":"clang/clang.html","title":"C Language","keywords":"","body":"C Language "},"clang/c-intro.html":{"url":"clang/c-intro.html","title":"Introduction to C","keywords":"","body":"Introduction to C "},"info-theo/info-theo.html":{"url":"info-theo/info-theo.html","title":"Information theory","keywords":"","body":"Information Theory 情報理論とは情報を数量的に捉える理論のことです Entropy Information Resource "},"info-theo/entropy.html":{"url":"info-theo/entropy.html","title":"Entropy","keywords":"","body":"Entropy "},"info-theo/info-res.html":{"url":"info-theo/info-res.html","title":"Information Resource","keywords":"","body":"Information Resource "},"info-geo/info-geo.html":{"url":"info-geo/info-geo.html","title":"Information geometry","keywords":"","body":"Information geometry "},"os/os.html":{"url":"os/os.html","title":"Operating system","keywords":"","body":"Operating system "},"os/intro.html":{"url":"os/intro.html","title":"Introduction to OS","keywords":"","body":"Introduction to OS "},"os/thread-proc.html":{"url":"os/thread-proc.html","title":"Thread & Process","keywords":"","body":"Thread & Process "},"os/c-assem.html":{"url":"os/c-assem.html","title":"C & Assembly","keywords":"","body":"C & Assembly "},"other/editor.html":{"url":"other/editor.html","title":"Editor","keywords":"","body":"Editor "},"other/latex.html":{"url":"other/latex.html","title":"Latex","keywords":"","body":"Latex "},"other/git.html":{"url":"other/git.html","title":"Git","keywords":"","body":"Git "}}