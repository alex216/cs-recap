# 03 C & Assembly

---
description: C言語とアセンブリに関して
---

# C & Assembly

## 目標

Cプログラムの実行を機械語レベルで｢イメージ｣できるように成ることが目標です

### なぜやるのか

本来,OSやCPUは言語に関係ないです

- OSはプログラムがどの言語で書かれていようと関係のない言語で設計されています
  - システムコール(API)の引数や返り値は整数やアドレスであり,Javaの配列やPerlの文字列ではないです
- CPUもあくまで機械語しかわかりません
  - スレッドがメモリを共有をしているのはC言語の処理系がやっているのではなくCPUとOSが提供しています

機械語ですべてやるのが正しいですが,それでは不必要に複雑になるという理由でC言語で説明します.また,

- システムコールのAPI説明はCの関数で説明するのが慣習
- スレッドがメモリを共有していることをC言語の変数や配列が共有されていることとして説明するのが慣習

### C言語を理解するメリット

- 初級
  - ポインタを理解できます
  - `malloc`などアドレス関連の関数を理解できます
  - `Segmentation Fault`を理解できます
- 中級
  - ポインタと配列の関係を理解できます
  - 関数呼び出しの実装に関して理解できます
- 上級
  - `C/C++`言語ならではの理解不能バグを理解できます

### 中心的なテーマ

Cプログラムによるメモリの使われ方について学びます

- 変数,配列がどこに格納され,どのような`C`の式,文がどのようにメモリをアクセスされるのか
- 関数呼び出しの仕組み
  - ローカル変数の格納場所(スタック)
  - 呼び出しの入れ子の実現
    - 制御構造,副プログラム,名前空間など

## CPU & メモリ

コンピュータは**レジスタ**と呼ばれるCPU内の少量の記憶領域と**メインメモリ**と呼ばれるCPU外の記憶領域を用いて計算を行う機械です

主記憶にはプログラムが使うあらゆるデータが格納されています

- ブラウザで開いているタブ,Terminalなど
- C言語の変数,配列など

主記憶は単なるバイト列です

- 主記憶へはアドレスを指定して記憶場所を指定します
- 番地は単なる整数です
- 番地として許される値にはある一定の制限が有ります

Cのプログラムもメモリをアクセスしているだけと言うことが可能です

そのため,｢常に変数,配列,などなどあらゆる記憶域がメモリのどこかにプログラムが正しい限り重ならないように格納されている｣ということを考慮してください

### ポインタ

ポインタとはつまりアドレスのことです

```C
char* p = ...;
```

- `p`に格納されているものはアドレス(整数)
- `*p`は`p`に格納されているアドレスをアクセスします
- `p[5]`は`pに格納されているアドレス+5`番地をアクセスしますす
- `p[0]`は`*p`の糖衣構文(syntax sugar)です

#### 実践

```C
int main() {
    char* p = 918;
    return *p;
}
```

このプログラムを実行するとエラー文が出てきます.それはOSをが間違った･悪意のあるプログラムからシステムを保護するために動いたからです(メモリ保護)

一般的な用語としてメモリ保護違反をすることには`Segmentation Fault`というUnix用語を使います

変数のアドレスを見るには以下のようなプログラムを書きます

```C
&x; // xの値が格納されているアドレス
```

```C
#include <stdio.h>
int s; // 単純な変数
typedef struct point{
    int x;
    int y;
} point;
point p; // 構造体の変数
int a[10]; // 配列
int main() {
    printf("%d %d %d %d %d %d\n", &s, &p.x, &p.y, &a[0], &a[5], &main);
}
```

### 実はアドレスなもの

```C
int x
&x; // 変数のアドレス
int a[10];
a; // 配列
int* s = "abc";
s; // 文字列
int* q = malloc(100);
q; // メモリ割り当て関数の返り値
int* p = 918;
p; // 実はアドレスは整数値
```

### C言語と他の言語の違い

どんな言語も究極的には機械語(整数･浮動小数点しかない)です.つまり,メモリに色々なものをおき,そのアドレスで表している仕組み自体は同じです

C言語の特徴はその｢仕組み｣をポインタという形で包み隠さず見せているところです.混乱の原因でもあり,自然かつ単純なところでもあります

### ポインタと配列の違い

```C
/** アドレス1個文の領域を確保
 * そこに勝手なアドレスを格納できます
 * intを格納するための領域は確保されていません
 */
int* p;

/** int 10個分の領域を確保します
 * aはその先頭のアドレスです
 */
int a[10];
```

### ポインタに関する知識

```C
int foo{
    int a[100];
    int* p;
    a[0] = 10; // OK
    p[0] = 10; // NG: どこにアクセスするか決まっていない
}
```

ポインタ変数へは初期化の必要があります

```C
int a[10];
int* p = a;
// 以下は同じ
a[0]; // p[0]
a[3]; // p[3]
(a+5); // (p+5)
// 以下は異なります
&a; // &p
```

### C言語で現れる3種類の記憶療育

- 大域(global)静的(static)変数･配列
  - 関数外に書かれた変数･配列
  - 関数中で`static`と書かれた変数･配列
- 局所(local)変数･配列
  - 関数定義の中に書かれた変数定義
- ヒープ
  - `malloc`, `new`(C++)などで確保される

#### 大域/静的

```C
// 大域変数
int x;
int a[10];
void foo() {
    // 静的変数
    static int y;
    static int b[10];
}
```

プログラム開始時に各変数,配列があるアドレスに割り当てられ,プログラム終了までその領域はその変数,配列のために確保され続けます

つまり,そのアドレスは他の目的には使われません

#### 局所

```C
int fib(int n) {
    if (n < 2) {
        return 1;
    } else {
        // 局所変数
        int x = fib(n-1);
        int y = fib(n-2);
        return x + y;
    }
}
```

`fib(10)`と`fib(9)`では`x`は別の領域である必要が有ります

実際にどのように実装されているかと言うと,**スタック**というデータ構造を用いて,関数が呼び出された時にその呼び出しの実行のための領域を見つけて確保します

スタックとは上から新しいものを入れて,上から取り除くようなデータ構造です

実際には以下のようなアルゴリズムでスタックに変数が格納されます

- 関数が実行を開始する時
  - その関数が使う局所変数の大きさに応じて空き領域からメモリを確保します
- 関数が終了する時
  - 開始時に確保した分だけメモリを開放します
- 確保･開放とはスタックポインタをずらすことです
- 各スレッドが一つのスタックを持っています

局所変数･配列はそれを確保した関数呼び出しが終了すると開放されます

#### スタックに関する知識

ほとんどのOS/CPUではスタックは大きい番地から小さい番地へ向かって伸びます

- 確保: `SP -= size;`
- 開放; `SP += size;`

小さい番地には命令列,大域変数,ヒープなどがありその方が都合が良かったのでは?と推測できます

現在ではスレッドが増えたので同じ手法ではできません

また,スタックは無限に伸びないので使いすぎると**スタックオーバーフロー**を起こします.原因は以下の通りです

- 巨大な局所配列
- 深すぎる関数呼び出しの入れ子

スタックの大きさはスレッド生成時に指定できます

#### 戻り番地

**戻り番地**とは関数終了後にジャンプする番地のことです

スタックにはこの戻り番地が格納されています

戻り番地が破壊されることを**バッファオーバラン**と言います

デタラメな番地に行ってしまうので,セキュリティホールの原因となります

しかし,デタラメな番地で済まずに攻撃する側が実行した命令が実行されるということも...

### ヒープ

||確保|開放|
|-|-|-|
|大域変数･配列\n静的変数･配列|プログラム開始時|されない(プログラム終了時)|
|局所変数･配列|関数開始時|関数終了時|
|ヒープ|任意(`malloc`, `new`)|任意(`free`, `delete`)|
