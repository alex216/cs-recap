# 02 Thread and Process

## スレッド･プロセスの目的

- CPUを仮想化することができます
  - 物理的なCPUの数は固定,少数,有限
    - PCやスマホは大概8コアまで
    - サーバーでも数十
  - しかし,それ以上のプログラムを立ち上げることが可能です
  - ここのプログラムを書く人が明示的な譲り合いをする必要はありません

## スレッドとは

**スレッド**とは制御の流れ

- OSが｢スレッドを作りたい｣と要求
- OSがスレッドにCPUを割り当て実行
- OSが交互にスレッド実行し,CPUが複数あれば各CPU上スレッドを作ります

## プロセスとは

**プロセス**とはプログラムを起動したときにできるもの

言い換えるとプロセスとは｢論理アドレス空間の生成+mainスレッド(1つ以上のスレッド)の生成｣

## 実際には

Linux: `ps`, `top`, `htop`

Windows: `perfmon`

などで現在走っているプロセスを見ることが可能です

## 関連API

スレッド･プロセスに関連するAPI

- 共通する主要概念
  - 生成･終了
  - 同期･実行の制御
- 代表的**スレッドAPI**
  - Unix: POSIX Threads(`pthread`)
  - Windows: Win32 thread
- 代表的**プロセスAPI**
  - Unix: POSIX
  - Windows: Win32

### プロセス生成

#### Unix

プロセスを作ること自体は`fork`で終わっています

`execv`では,現在のプロセスを新しいプロセスイメージで置き換え実行します

```C
pid = fork(); /* プロセス複製 */
if (pid == 0) { /* 子プロセス */
    execv(file, cmdline); /* fileを実行 */
} else { /* 親プロセス */ }
```

#### Windows

`file`をコマンドライン`cmd`で起動します

`CreateProcess(file, cmd, ...., &pid);`

### プロセス終了

プロセスの終了はWindowsとUnixで以下のように行われます

Win: `ExitProcess(s)`

Unix: `eixt(s)`

またはプログラムの`main`関数が終了した時に自動的に終了します

### プロセス終了待ち

プロセス`pid`が終了するのを待つAPIは以下の通りです

Win: `WaitForSingleObject(pid, timeout)`

Winは待つ時には同じAPIを使います

Unix:

- `wait(&status)`
- `waitpid(pid, &status,...)`

### 高水準なAPI

Unixの場合,最終的には`fork`, `exec`, `waitpid`などの組み合わせに過ぎません

- `system(command_string)`
  - `command_string`を実行するプロセスを作り終了を待ちます
  - `fork`+`exec`+`wait`
- `popen(command_string)`
  - `command_string`を実行するプロセスを作り,そのプロセスと通信するチャネル(パイプ)を返します
  - `pipe`作り+`fork`+`exec`

### スレッド生成

- 命令列が始まるアドレスを指定します
  - そこから実行を開始するスレッドを生成します
- 命令列のアドレス=Cの関数ポインタ

#### スレッド生成実例

`f(x)`を実行するスレッドを生成し,スレッド名を`id`に格納する関数は以下の通りです

Unix: `pthread_create(&id, ..., f, x)`

Wind: `CreateThread(..., ..., f, x, ..., 'id)`

### スレッド終了

`s`とは'status'のことです

#### スレッド終了実例

Unix: `pthread_exit(s)`

Win: `ExitThread(s)`

また,生成時に指定された関数が`f`が終了すると自動的にスレッドは終了します

### スレッドの終了待ち

スレッド`id`が終了するのを待ちます

`id`は`pthread_craete`などによって得られたスレッド名です

#### スレッド終了待ち実例

Unix: `pthread_join(id, &return_status)`

Win: `WaitforSingleObject(id, timeout)`

### その他の言語

ほとんどの言語でスレッド,プロセス関係のAPIは提供されています

(上ではC言語が例ですが, Java, C++, Pythonなどでも同様)

- 名前が異なることは多いですが,概念は似ています
- 多くの場合はC言語用のライブラリから`fork`, `exec`などを呼び出しているだけです(Unixの場合)

## プロセスとスレッド

両者は似ているように思えますが,実際に違います

現時点では

- スレッド...一筋の実行の流れ
- プロセス...プログラムを起動した時にできるもの
  - 箱+1個以上のスレッド
  - `main`を実行するスレッドはプロセスと共に自動的に作られます

## スケジューリング

システムには多数のスレッドが同時に存在します

多くの場合ではCPUの数<スレッド数

OSの役割は**適切に**CPUを割り当てることで,そのためにスケジューリングが必要になります

### スケジューリングの目標

- 公平性
  - 独占的に割り当てないようにします
  - 公平にCPUに割り当てます
- 効率性
  - 実行可能なスレッドがある限り, CPUが休まないように動かせます
  - スレッド切り替えのときのオーバーヘッドを少なくします
- 対話的プログラムの応答性

### スケジューラの挙動を観察する

- いくつかのスレッドを立ち上げます
- スレッドがいつからいつまで実行中だったのかを調べます
  - これには時刻を知るシステムコールが必要です
- 観察する点
  - どれくらいの頻度でスレッドが入れ替わっているのか
  - その状態でのエディタやブラウザの応答性に影響はあるのか

```C
f(x) {
    t1 = currentTime();
    while(1) {
        t2 = currentTime();
        if (t2 - t1 > 1) {
            /* CPUをしばらく使われている */
        }
        t1 = t2;
    }
    /* 記録を出力 */
}
```

#### 時刻を知るシステムコール

Unix: `gettimeofday`

Win: `QueryPerformanceCounter`

#### 特定のCPUへスレッドを固定

- システムコール
  - `sched_setafinity(pid, size, mask)`
    - `mask`: size bitのbit列
    - `mask`で1となっているCPUでのみ,`pid`を実行
  - 子プロセスへ自動的に継承
- コマンド
  - `taskset -c <CPUの番号(0,1,2,...)> command`

### スレッドスケジューラの実現

#### クイズ

- 無限ループするプログラムを書いて実行してもマウスが動き,ブラウザが動き,(多くの場合)Ctrl-Cで消せるのはなぜ?
  - **割り込み処理**がされるから

### OSのないCPU

クイズのような答えに成るのはCPU自体の動作は以下のようになっているからです

- CPUの状態はレジスタに入っています
  - 汎用
  - プログラムカウンタの入っている命令を実行する
  - CPUモードに応じて操作が制限されています
- CPUの動作は
    ```text
    <<<外部割込が発生していれば割り込み処理>>>
    PC(プログラミングカウンタ)が指す場所の命令を取り出す
    命令を実行し状態を書き換える
    ```

### 割り込み処理

**割り込み**とはCPU外部からの信号のことです

割り込みの時にCPUが行うことは以下のようになっています

```text
if (割り込み許可中) {
    割り込みを禁止する
    一部の状態(割り込み発生時PC(など))を特定のレジスタに保存
    割り込みベクタを参照し指定されている値をPCに設定(制御の移動)
    <<特権モードへ移行>>
}
```

#### 割り込みベクタ

**割り込みベクタ**とは割り込みの要因を示す番号のことです

CPUに直接命令をします

割り込みベクタは通常OSの起動時に設定されます

#### IRQ

**IRQ**とはキーバード･マウスなどの入出力デバイスがCPUを呼び出す時に生じる割り込み要求のことです

- IRQの通常の用途
  - 入出力
    - キーボード･ネットワークコントローラ
    - タイマ
- システムコール(トラップ命令)

#### タイマ割り込み

これはCPUの独占を防ぐための鍵です

通常定期的に発生させます(1-10ms程度に1回発生します)

- Linux(2.4) on x86, Windows on x86, BSDなどで10ms
- Linux on Alpha 1ms
- Linux 2.6.22以前は1ms, 4ms, または必要に応じて発生させます

タイマ割り込み間隔･クロック間隔･クロックチックなどと呼び,必要な時にOSがCPUをアプリケーションから奪う機会を保証します

#### 各スレッドの状態

![各スレッドの状態](img/thread.dot.svg)

#### 中断状態

**中断状態**とは(CPUが空いていても)直ちに実行することができない状態のことです

OSは中断状態のスレッドをCPU割当の対象から外します

#### 中断と復帰

- スレッドが中断する理由
  - 入出力待ち(recv, read, etc)
  - 自主的休眠(sleep)
  - スレッド間の同期(pthread_join, wait, etc)
  - ページフォルト
- 復帰の理由(中断の逆)
  - 入出力完了
  - 休眠時間経過
  - スレッド間の同期成立
  - ページフォルト処理完了

### 実行可能キュー

**実行可能キュー**とは実行可能スレッドのリストのことです

｢スケジューリングキュー｣,｢ランキュー｣などという名前で呼ばれることがあります

スレッドが実行可能キューにあるといことはそのキューが実行可能であるということです

OSが機会あるごとに実行可能キューから最も適切なスレッドを選んで実行することを**reschedule**と呼びます

#### 中断

ネットワークからのデータ待ちによる中断を例とします

```text
recv() {
    ...
    if (読むべきdataがない) {
        現スレッドを実行可能キューから外す
        reschedule()
    }
    ...
}
```

#### 中断からの復帰

ネットワークからのデータ到着による復帰を例とします

```text
/* 割り込み→OSのネットワークからの入力を処理 */
if (あるスレッドが今到着したデータ待ち) {
    そのスレッドを実行可能キューに入れる
    reschedule()
}
```

#### Rescheduleの機会

OSが制御を得るあらゆる時点が潜在的な`reschedule`の機会です

- タイマ割り込み時
  - クロック間隔に一度
- その他の割り込み(入力)からの復帰時
- 実行スレッドが中断した時
- システムコードからの復帰時
- etc

`reschedule`の機会をOSが得るたびに｢次に実行すべきスレッド｣を選択して実行します.つまりCPUの割当をしています

次に実行すべきスレッドの選択の仕方が重要です

- 公平性
- 効率性
- 対話的プログラムの応答

#### 対話的なスレッドの応答性

エディタ,ブラウザ,メーラに｢キー入力｣をしたらすぐに反応してほしいです

これに対応する対話的なスレッドは基本的には｢入力待ち｣です.そして以下の特徴が有ります

- I/Oによる中断が非常に頻繁
- キーボード,マウス,ネットワークなどの入力待ち
- 中断が多いため,CPU利用量は少ないです

#### 現在のLinuxスケジューラ

カーネル2.6.23以降は`Completely Fair Scheduler(CFS)`が使われています

特徴としては

- 各スレッドが使用したCPU時間を累積で管理しています
  - `vruntime(virtual runtime)`
- `reschedule`時には毎回`vruntime`が最小のスレッドを選びます
  - つまり最もCPUを使っていないスレッドを選びます
  - 公平性の保証をしています


#### `vruntime`管理の実際

`vruntime`は以下のように管理されています

- スレッドが生まれた時
  - 子は親の`vruntime`を引き継ぐ
  - 子の`vruntime` = 0とはならない
- スレッドがAからBに切り替わる時
  - `Aのvruntime += 今回消費した時間`
  - `Bのvruntime = そのまま`
    - しかしそれでは問題があります
    - Bの`vruntime`は最初0なとき,他のスレッドの`vruntime`が100msだったときに100msも動かせます
    - それではまずいので`Bのvruntime (他のスレッドの最小vruntime) - 20ms`を保証します
